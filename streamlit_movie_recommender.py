{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Setup of Streamlit"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Popular Movies Section"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "from sklearn.metrics.pairwise import cosine_similarity\n",
    "from sklearn.feature_extraction.text import CountVectorizer\n",
    "\n",
    "# Load data\n",
    "links_df = pd.read_csv('links.csv')\n",
    "movies_df = pd.read_csv('movies.csv')\n",
    "ratings_df = pd.read_csv('ratings.csv')\n",
    "tags_df = pd.read_csv('tags.csv')\n",
    "\n",
    "# Preprocessing\n",
    "## Calculate average rating and rating count for each movie\n",
    "ratings_mean_count = ratings_df.groupby('movieId').agg({'rating': ['mean', 'count']})\n",
    "ratings_mean_count.columns = ['average_rating', 'rating_count']\n",
    "\n",
    "## Merge with movies_df\n",
    "movies_df = pd.merge(movies_df, ratings_mean_count, on='movieId', how='left')\n",
    "\n",
    "# Replace NaN values in average_rating and rating_count with 0\n",
    "movies_df['average_rating'].fillna(0, inplace=True)\n",
    "movies_df['rating_count'].fillna(0, inplace=True)\n",
    "\n",
    "# Create movie title and genres dataframe (used in item-based recommendation)\n",
    "movie_info_df = movies_df[['movieId', 'title', 'genres']]\n",
    "\n",
    "# Preparing data for user-based recommendation\n",
    "## Create a user-movie matrix\n",
    "user_movie_matrix = ratings_df.pivot_table(index='userId', columns='movieId', values='rating')\n",
    "\n",
    "# Normalize the ratings by subtracting the mean rating for each user\n",
    "mean_user_rating = user_movie_matrix.mean(axis=1)\n",
    "user_movie_matrix_norm = user_movie_matrix.sub(mean_user_rating, axis='user')\n",
    "\n",
    "# Replace NaN values with 0\n",
    "user_movie_matrix_norm.fillna(0, inplace=True)\n",
    "\n",
    "# Create a sparse matrix for more efficient calculations\n",
    "user_movie_sparse = csr_matrix(user_movie_matrix_norm.values)\n",
    "\n",
    "# Compute the cosine similarity matrix\n",
    "user_similarity = cosine_similarity(user_movie_sparse)\n",
    "user_similarity_df = pd.DataFrame(user_similarity, index=user_movie_matrix_norm.index, columns=user_movie_matrix_norm.index)\n",
    "\n",
    "# Preparing data for item-based recommendation\n",
    "## Create a movie-user matrix\n",
    "movie_user_matrix = user_movie_matrix.T\n",
    "\n",
    "# Normalize the ratings by subtracting the mean rating for each movie\n",
    "mean_movie_rating = movie_user_matrix.mean(axis=1)\n",
    "movie_user_matrix_norm = movie_user_matrix.sub(mean_movie_rating, axis='movie')\n",
    "\n",
    "# Replace NaN values with 0\n",
    "movie_user_matrix_norm.fillna(0, inplace=True)\n",
    "\n",
    "# Create a sparse matrix for more efficient calculations\n",
    "movie_user_sparse = csr_matrix(movie_user_matrix_norm.values)\n",
    "\n",
    "# Compute the cosine similarity matrix\n",
    "movie_similarity = cosine_similarity(movie_user_sparse)\n",
    "movie_similarity_df = pd.DataFrame(movie_similarity, index=movie_user_matrix_norm.index, columns=movie_user_matrix_norm.index)\n",
    "\n",
    "# App Title\n",
    "st.title('Movie Recommender System')\n",
    "\n",
    "# Popular Movies Section\n",
    "st.header('Popular Movies')\n",
    "num_movies_show = st.slider('Number of Popular Movies to Show', 5, 50, 10)\n",
    "popular_movies = movies_df.sort_values(by=['rating_count', 'average_rating'], ascending=False).head(num_movies_show)\n",
    "st.write(popular_movies[['title', 'average_rating', 'rating_count']])\n",
    "\n",
    "# Item-based Recommendation Section\n",
    "st.header('Item-based Movie Recommendations')\n",
    "selected_movie = st.selectbox('Select a Movie', movies_df['title'].values)\n",
    "if selected_movie:\n",
    "    selected_movie_idx = movie_info_df[movie_info_df['title'] == selected_movie].index[0]\n",
    "    similar_movies = list(enumerate(movie_similarity[selected_movie_idx]))\n",
    "    sorted_similar_movies = sorted(similar_movies, key=lambda x: x[1], reverse=True)[1:]\n",
    "    item_based_recommendations = [movie_info_df['title'].iloc[i[0]] for i in sorted_similar_movies[:10]]\n",
    "    st.write('Movies similar to', selected_movie, ':')\n",
    "    st.write(item_based_recommendations)\n",
    "\n",
    "# User-based Recommendation Section\n",
    "st.header('User-based Movie Recommendations')\n",
    "user_id = st.number_input('Enter User ID', min_value=1)\n",
    "if user_id in user_similarity_df.index:\n",
    "    similar_users = list(enumerate(user_similarity[user_id]))\n",
    "    sorted_similar_users = sorted(similar_users, key=lambda x: x[1], reverse=True)[1:]\n",
    "    top_similar_user = sorted_similar_users[0][0]\n",
    "    user_based_recommendations = user_movie_matrix.loc[top_similar_user].sort_values(ascending=False).head(10).index\n",
    "    recommended_movies = movies_df[movies_df['movieId'].isin(user_based_recommendations)]['title']\n",
    "    st.write('Recommended Movies for User ID', user_id, ':')\n",
    "    st.write(recommended_movies)\n",
    "else:\n",
    "    st.write('User ID not found in the dataset.')\n",
    "\n",
    "# Run this script using: streamlit run script_name.py"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "base",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
